<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>write - nuuko</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="icon" type="image/svg+xml" href="assets/character/feather-character.svg">
    <meta name="description" content="Your cozy space for reflection and journaling">
</head>
<body>
    <!-- Navigation -->
    <nav class="nav" role="navigation">
        <div class="nav-content">
            <a href="index.html" class="nav-logo">
                <img src="assets/character/feather-character.svg" alt="nuuko feather" class="feather" style="width: 24px; height: 24px;">
                <span class="nav-brand">nuuko</span>
            </a>
            
            <div class="nav-links">
                <a href="index.html" class="nav-link">
                    <img src="assets/icons/icon-library.svg" alt="home" class="icon" style="width: 16px; height: 16px;">
                    <span>home</span>
                </a>
                <a href="write.html" class="nav-link active">
                    <img src="assets/icons/icon-journal.svg" alt="write" class="icon" style="width: 16px; height: 16px;">
                    <span>write</span>
                </a>
                <a href="insights.html" class="nav-link">
                    <img src="assets/icons/icon-insights.svg" alt="insights" class="icon" style="width: 16px; height: 16px;">
                    <span>patterns</span>
                </a>
                <a href="feedback.html" class="nav-link">
                    <img src="assets/icons/icon-feedback.svg" alt="feedback" class="icon" style="width: 16px; height: 16px;">
                    <span>feedback</span>
                </a>
            </div>
        </div>
    </nav>

    <!-- Main Content -->
    <main class="container" style="padding-top: 2rem; padding-bottom: 3rem; max-width: 1000px;">
        
        <!-- Header -->
        <header class="text-center mb-2xl fade-in">
            <input
                id="pageTitle"
                class="entry-title-input mb-sm"
                type="text"
                value="new entry"
                aria-label="entry title"
            >
            <div class="date-picker-shell">
                <p class="text-muted" id="currentDate" style="font-size: 1.125rem; margin: 0;">monday, january 27</p>
                <button type="button" class="date-display" id="datePickerTrigger" aria-expanded="false" aria-controls="datePickerPopover">
                    <span id="dateDisplayValue">11/20/2025</span>
                    <svg class="date-display-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 256 256" fill="currentColor" aria-hidden="true">
                        <path d="M208 32h-20V24a12 12 0 0 0-24 0v8h-48V24a12 12 0 0 0-24 0v8H72a24.1 24.1 0 0 0-24 24v144a24.1 24.1 0 0 0 24 24h136a24.1 24.1 0 0 0 24-24V56a24.1 24.1 0 0 0-24-24Zm8 168a8 8 0 0 1-8 8H72a8 8 0 0 1-8-8V104h152Zm0-120H64V56a8 8 0 0 1 8-8h16v8a12 12 0 0 0 24 0v-8h48v8a12 12 0 0 0 24 0v-8h16a8 8 0 0 1 8 8Z" />
                    </svg>
                </button>
                <input type="hidden" id="entryDate" name="entryDate" aria-label="choose entry date">
                <div id="datePickerPopover" class="date-popover hidden" role="dialog" aria-label="choose entry date">
                    <div class="date-popover-header">
                        <button type="button" class="date-nav" id="datePrevMonth" aria-label="previous month">‹</button>
                        <div class="date-month" id="dateMonthLabel">November 2025</div>
                        <button type="button" class="date-nav" id="dateNextMonth" aria-label="next month">›</button>
                    </div>
                    <div class="date-weekdays" id="dateWeekdays"></div>
                    <div class="date-grid" id="dateGrid"></div>
                    <div class="date-footer">
                        <button type="button" class="btn-ghost date-foot-btn" id="dateToday">today</button>
                        <button type="button" class="btn-ghost date-foot-btn" id="dateClose">close</button>
                    </div>
                </div>
            </div>
            <div style="width: 64px; height: 4px; background: linear-gradient(to right, var(--nuuko-green), var(--nuuko-clay)); border-radius: 2px; margin: 0 auto; opacity: 0.6;"></div>
        </header>

        <!-- Prompt Section -->
        <section id="promptSection" class="card-minimal paper-texture mb-xl slide-up" style="border-left: 4px solid rgba(107, 143, 113, 0.4); animation-delay: 0.1s; max-width: 600px; margin-left: auto; margin-right: auto;">
            <div class="flex flex-col gap-md">
                <div class="flex items-center justify-between gap-md">
                    <div class="flex items-center gap-md">
                        <button type="button" onclick="changePrompt()" aria-label="new prompt" style="border: none; width: 48px; height: 48px; border-radius: 50%; background: rgba(107, 143, 113, 0.18); display: flex; align-items: center; justify-content: center; cursor: pointer; box-shadow: inset 0 1px 2px rgba(255,255,255,0.5);">
                            <img src="assets/icons/magic-wand-icon.svg" alt="change prompt" style="width: 22px; height: 22px;">
                        </button>
                        <div>
                            <p style="margin: 0; font-size: 0.75rem; letter-spacing: 0.2em; text-transform: uppercase; color: rgba(61,52,44,0.6);">today's reflection prompt</p>
                            <p class="italic text-muted" id="writePagePrompt" style="font-size: 1rem; margin: 0; color: var(--nuuko-stone); border-bottom: 2px dashed rgba(154, 107, 81, 0.3); display: inline-block;">what surprised you today?</p>
                        </div>
                    </div>
                    <div class="flex items-center gap-xs">
                        <button type="button" aria-label="edit prompt" onclick="startPromptEdit()" style="border: 1px solid rgba(61,52,44,0.12); width: 40px; height: 40px; border-radius: 50%; background: rgba(61, 52, 44, 0.06); color: var(--nuuko-espresso); display: flex; align-items: center; justify-content: center; cursor: pointer;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 256 256" fill="currentColor" aria-hidden="true">
                                <path d="M225.9 74.6 181.4 30.1a13.9 13.9 0 0 0-19.8 0L32.9 158.8a8.1 8.1 0 0 0-2.3 5.1l-4 48a8 8 0 0 0 8.7 8.7l48-4a8.1 8.1 0 0 0 5.1-2.3L225.9 94.4a13.9 13.9 0 0 0 0-19.8ZM91.3 204.7l-30.3 2.5 2.5-30.3L145 95.4l27.8 27.8Zm88.4-88.4L152 88.6l27.8-27.8 27.8 27.8Z" />
                            </svg>
                        </button>
                        <button type="button" aria-label="hide prompt" onclick="dismissPromptSection()" style="border: 1px solid rgba(61,52,44,0.12); width: 40px; height: 40px; border-radius: 50%; background: rgba(61, 52, 44, 0.06); color: var(--nuuko-espresso); display: flex; align-items: center; justify-content: center; cursor: pointer;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 256 256" fill="currentColor" aria-hidden="true">
                                <path d="M205.7 58.3a8 8 0 0 0-11.4 0L128 124.7 61.7 58.3a8 8 0 0 0-11.4 11.4L116.7 136l-66.4 66.3a8 8 0 0 0 11.4 11.4L128 147.3l66.3 66.4a8 8 0 0 0 11.4-11.4L139.3 136l66.4-66.3a8 8 0 0 0 0-11.4Z" />
                            </svg>
                        </button>
                    </div>
                </div>
                <div id="promptEditor" class="hidden" style="margin-top: 0.5rem;">
                    <textarea id="promptEditInput" rows="2" style="width: 100%; padding: 0.75rem 1rem; border-radius: 1rem; border: 1px solid rgba(154,107,81,0.25); font-size: 0.95rem; font-family: var(--font-serif); color: var(--nuuko-espresso);"></textarea>
                    <div class="flex items-center justify-center gap-sm" style="margin-top: 0.5rem;">
                        <button type="button" class="btn btn-primary text-sm" onclick="savePromptEdit()" style="display: inline-flex; gap: 0.35rem;">
                            <span>save</span>
                        </button>
                        <button type="button" class="btn btn-ghost text-sm" onclick="cancelPromptEdit()">cancel</button>
                    </div>
                </div>
            </div>
        </section>

        <div id="promptHiddenNotice" class="hidden text-center slide-up" style="animation-delay: 0.1s; margin-bottom: 1.5rem;">
            <div class="card-minimal paper-texture" style="padding: 1rem 1.5rem; display: inline-flex; gap: 0.75rem; align-items: center;">
                <span style="color: var(--nuuko-stone); font-size: 0.9rem;">prompt hidden for this entry.</span>
                <button type="button" class="btn btn-ghost text-sm" onclick="restorePromptSection()">show prompt</button>
            </div>
        </div>

        <!-- Large Writing Notebook -->
        <section class="slide-up" style="animation-delay: 0.2s;">
            <div class="card paper-texture writing-notebook" style="position: relative; overflow: hidden; background: rgba(255, 255, 255, 0.95); box-shadow: 0 8px 32px rgba(61, 52, 44, 0.1), 0 3px 12px rgba(61, 52, 44, 0.06); min-height: 600px;">
                <!-- Enhanced notebook lines -->
                <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; opacity: 0.05; pointer-events: none; background-image: repeating-linear-gradient(transparent, transparent 1.8rem, var(--nuuko-stone) 1.8rem, var(--nuuko-stone) calc(1.8rem + 1px));"></div>
                
                <!-- Left margin line with subtle style -->
                <div style="position: absolute; top: 0; bottom: 0; left: 4rem; width: 2px; background: linear-gradient(180deg, rgba(154, 107, 81, 0.2) 0%, rgba(154, 107, 81, 0.1) 100%); pointer-events: none; border-radius: 1px;"></div>
                
                <!-- Top margin -->
                <div style="position: absolute; top: 3rem; left: 4rem; right: 2rem; height: 1px; background: rgba(154, 107, 81, 0.15); pointer-events: none;"></div>
                
                <!-- Three hole punch effect -->
                <div class="notebook-holes" style="position: absolute; top: 80px; left: 20px; width: 12px; height: 12px; background: rgba(61, 52, 44, 0.08); border-radius: 50%; pointer-events: none;"></div>
                <div class="notebook-holes" style="position: absolute; top: 200px; left: 20px; width: 12px; height: 12px; background: rgba(61, 52, 44, 0.08); border-radius: 50%; pointer-events: none;"></div>
                <div class="notebook-holes" style="position: absolute; top: 320px; left: 20px; width: 12px; height: 12px; background: rgba(61, 52, 44, 0.08); border-radius: 50%; pointer-events: none;"></div>
                
                <form id="writingForm" style="position: relative; z-index: 1; height: 100%;">
                    <textarea 
                        id="writingArea"
                        class="writing-area"
                        placeholder="start writing here..."
                        aria-label="Your journal entry"
                        style="
                            padding: 4rem 3rem 3rem 5rem; 
                            min-height: 600px; 
                            font-size: 1.125rem; 
                            line-height: 1.8;
                            border: none;
                            background: transparent;
                            resize: none;
                            width: 100%;
                            font-family: var(--font-sans);
                            color: var(--nuuko-espresso);
                        "
                    ></textarea>
                </form>
            </div>
        </section>

        <!-- Controls Row -->
        <div class="grid write-controls slide-up" style="grid-template-columns: 1fr 1fr 1fr; gap: 2rem; margin-top: 2rem; animation-delay: 0.3s;">
            <!-- Mood -->
            <section class="card-minimal paper-texture">
                <h3 class="mb-lg text-center" style="font-size: 1rem;">how are you feeling?</h3>
                
                <div class="mood-spectrum" id="moodSpectrum">
                    <div class="mood-thumb" id="moodThumb" style="left: 50%;"></div>
                </div>
                
                <div class="mood-labels" style="display: grid; grid-template-columns: repeat(5, 1fr); font-size: 0.8rem; text-transform: lowercase; color: var(--nuuko-stone); margin-top: 0.75rem;">
                    <span style="text-align: left;">anxious</span>
                    <span style="text-align: center;">sad</span>
                    <span style="text-align: center;">neutral</span>
                    <span style="text-align: center;">calm</span>
                    <span style="text-align: right;">happy</span>
                </div>
                
                <div class="mood-current text-center">
                    <p id="currentMood">neutral</p>
                </div>
            </section>

            <!-- Stats -->
            <section class="card-minimal paper-texture text-center">
                <h3 class="mb-lg" style="font-size: 1rem;">your words</h3>
                <div style="display: grid; gap: 1rem;">
                    <div>
                        <div style="font-size: 1.5rem; font-weight: 600; color: var(--nuuko-clay);" id="wordCount">0</div>
                        <div style="font-size: 0.875rem; color: var(--nuuko-stone);">words</div>
                    </div>
                    <div>
                        <div style="font-size: 1.5rem; font-weight: 600; color: var(--nuuko-green);" id="readingTime">1 min</div>
                        <div style="font-size: 0.875rem; color: var(--nuuko-stone);">reading time</div>
                    </div>
                </div>
            </section>

            <!-- Actions -->
            <section class="card-minimal paper-texture">
                <div style="display: flex; flex-direction: column; gap: 1rem; justify-content: center; height: 100%;">
                    <button 
                        id="saveButton" 
                        class="btn btn-primary w-full btn-lg"
                        disabled
                        style="justify-content: center;"
                    >
                        <img src="assets/icons/icon-journal.svg" alt="save" style="width: 16px; height: 16px;">
                        <span id="saveButtonText">save page</span>
                    </button>
                    
                    <button 
                        id="deleteButton" 
                        type="button"
                        class="btn btn-ghost w-full hidden"
                        style="justify-content: center; color: var(--mood-anxious); border: 1px dashed rgba(214, 126, 126, 0.4);"
                    >
                        <img src="assets/icons/streak-icon.svg" alt="delete" style="width: 16px; height: 16px;">
                        <span>delete entry</span>
                    </button>
                    
                    <a href="index.html" class="btn btn-ghost w-full" style="justify-content: center;">
                        <img src="assets/icons/icon-library.svg" alt="home" style="width: 16px; height: 16px;">
                        <span>back home</span>
                    </a>
                </div>
            </section>
        </div>

        <!-- Entry Details -->
        <section class="card-minimal paper-texture slide-up" style="margin-top: 2rem; animation-delay: 0.35s;">
            <div id="editingBanner" class="hidden" style="display: flex; flex-wrap: wrap; gap: 0.75rem; align-items: center; justify-content: space-between; margin-bottom: 1.25rem; padding: 0.75rem 1rem; border: 1px dashed rgba(154, 107, 81, 0.3); border-radius: 12px; background: rgba(154, 107, 81, 0.08);">
                <p id="editingBannerText" style="margin: 0; font-size: 0.95rem; color: var(--nuuko-espresso);"></p>
                <button id="cancelEditingButton" type="button" class="btn btn-ghost" style="padding: 0.35rem 0.75rem;">start fresh</button>
            </div>
            <div class="summary-toggle-card">
                <div class="summary-toggle-copy">
                    <p class="summary-toggle-label">include in ai summaries</p>
                    <p class="summary-toggle-subtext">keep this reflection in the next summary</p>
                </div>
                <label class="summary-toggle-control" for="summaryToggle">
                    <input type="checkbox" id="summaryToggle" checked aria-label="Include this entry when generating summaries">
                    <span class="summary-toggle-thumb" aria-hidden="true"></span>
                </label>
            </div>
        </section>

        <!-- Error Message -->
        <div id="errorMessage" class="hidden mt-lg" style="background: rgba(214, 126, 126, 0.1); border: 1px solid rgba(214, 126, 126, 0.3); border-radius: 12px; padding: 1rem; backdrop-filter: blur(8px); max-width: 600px; margin: 2rem auto 0;">
            <p style="color: var(--mood-anxious); font-size: 0.875rem; margin: 0; text-align: center;"></p>
        </div>
        
        <div id="statusBanner" class="hidden" style="background: rgba(107, 143, 113, 0.12); border: 1px solid rgba(107, 143, 113, 0.3); color: var(--nuuko-green); border-radius: 12px; padding: 0.85rem 1rem; backdrop-filter: blur(8px); max-width: 600px; margin: 1rem auto 0; font-size: 0.9rem; text-align: center;"></div>
    </main>

    <!-- Success Modal -->
    <div id="successModal" class="hidden" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(61, 52, 44, 0.8); backdrop-filter: blur(8px); z-index: 1000; align-items: center; justify-content: center; padding: 2rem;">
        <div class="card text-center paper-texture" style="max-width: 400px; width: 100%;">
            <div style="width: 80px; height: 80px; background: linear-gradient(135deg, rgba(107, 143, 113, 0.2) 0%, rgba(154, 107, 81, 0.2) 100%); border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 1.5rem; backdrop-filter: blur(8px);">
                <img src="assets/icons/streak-icon.svg" alt="success" style="width: 40px; height: 40px;" class="float">
            </div>
            <h2 class="mb-sm">nice start</h2>
            <p class="mb-lg">your words are now part of your collection</p>
            <button id="closeModal" class="btn btn-primary">
                <img src="assets/icons/icon-library.svg" alt="home" style="width: 16px; height: 16px;">
                <span>back home</span>
            </button>
        </div>
    </div>

    <!-- JavaScript -->
    <script src="storage.js"></script>
    <script src="summary.js"></script>
    <script src="promptEngine.js"></script>
    <script src="script.js"></script>
    <script>
        (function () {
            const DRAFT_KEY = 'nuuko_draft';
            const moods = ['anxious', 'sad', 'neutral', 'calm', 'happy'];
            const FALLBACK_PROMPTS = [
                'what surprised you today?',
                'what made you smile recently?',
                'what challenged you today?',
                'what did you learn about yourself?',
                'what moment do you want to remember?'
            ];
            const promptEngine = window.NuukoPromptEngine;
            
            let currentMoodPosition = 50;
            let wordCount = 0;
            let editingEntry = null;
            let originalUpdatedAt = null;
            let currentPromptData = null;
            
            const writingArea = document.getElementById('writingArea');
            const moodSpectrum = document.getElementById('moodSpectrum');
            const moodThumb = document.getElementById('moodThumb');
            const currentMoodDisplay = document.getElementById('currentMood');
            const wordCountDisplay = document.getElementById('wordCount');
            const readingTimeDisplay = document.getElementById('readingTime');
            const saveButton = document.getElementById('saveButton');
            const saveButtonText = document.getElementById('saveButtonText');
            const deleteButton = document.getElementById('deleteButton');
            const errorMessage = document.getElementById('errorMessage');
            const statusBanner = document.getElementById('statusBanner');
            const successModal = document.getElementById('successModal');
            const closeModal = document.getElementById('closeModal');
            const currentDateDisplay = document.getElementById('currentDate');
            const writePagePrompt = document.getElementById('writePagePrompt');
            const promptEditor = document.getElementById('promptEditor');
            const promptEditInput = document.getElementById('promptEditInput');
            const promptHiddenNotice = document.getElementById('promptHiddenNotice');
            const promptSectionCard = document.getElementById('promptSection');
            const tagsInput = document.getElementById('tagsInput');
            const summaryToggle = document.getElementById('summaryToggle');
            const editingBanner = document.getElementById('editingBanner');
            const editingBannerText = document.getElementById('editingBannerText');
            const cancelEditingButton = document.getElementById('cancelEditingButton');
            const pageTitle = document.getElementById('pageTitle');
            
            if (!writingArea) return;
            
            const urlParams = new URLSearchParams(window.location.search);
            const entryIdParam = urlParams.get('entryId');
            
            const storageReady = window.NuukoStorage?.ready
                ? NuukoStorage.ready.catch((error) => {
                    console.warn('[Nuuko] storage init issue on write page:', error);
                })
                : Promise.resolve();
            
            const dateInput = document.getElementById('entryDate');
            const datePickerTrigger = document.getElementById('datePickerTrigger');
            const datePopover = document.getElementById('datePickerPopover');
            const dateGrid = document.getElementById('dateGrid');
            const dateMonthLabel = document.getElementById('dateMonthLabel');
            const dateWeekdays = document.getElementById('dateWeekdays');
            const datePrevMonth = document.getElementById('datePrevMonth');
            const dateNextMonth = document.getElementById('dateNextMonth');
            const dateTodayButton = document.getElementById('dateToday');
            const dateCloseButton = document.getElementById('dateClose');
            const dateDisplayValue = document.getElementById('dateDisplayValue');
            let currentDateLabel = '';
            let calendarCursor = startOfMonth(new Date());
            const today = new Date();
            initializeDateControls(today);
            updateDateDisplay(today);
            
            init();
            
            function init() {
                attachEventListeners();
                updateMoodDisplay();
                autoResize();
                syncPromptFromSettings();
                loadEnginePrompt();
                evaluatePageTitle();
                
                storageReady.then(() => {
                    if (entryIdParam) {
                        loadEntryForEditing(entryIdParam);
                    } else {
                        applyDraftIfRelevant();
                    }
                });
            }
            
            function attachEventListeners() {
                writingArea.addEventListener('input', () => {
                    updateStats();
                    autoResize();
                    hideError();
                    persistDraft();
                });
                
                writingArea.addEventListener('keydown', autoResize);
                
                if (moodSpectrum) {
                    moodSpectrum.addEventListener('click', (e) => {
                        const rect = moodSpectrum.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const percentage = Math.max(0, Math.min(100, (x / rect.width) * 100));
                        setMoodPosition(percentage);
                        persistDraft();
                    });
                }
                
                tagsInput?.addEventListener('input', persistDraft);
                summaryToggle?.addEventListener('change', persistDraft);
                dateInput?.addEventListener('change', handleDateChange);
                datePickerTrigger?.addEventListener('click', toggleCalendar);
                datePrevMonth?.addEventListener('click', () => shiftCalendar(-1));
                dateNextMonth?.addEventListener('click', () => shiftCalendar(1));
                dateTodayButton?.addEventListener('click', () => jumpToDate(startOfDay(new Date())));
                dateCloseButton?.addEventListener('click', closeCalendar);
                document.addEventListener('click', handleClickOutsideCalendar);
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        closeCalendar();
                    }
                });
                
                saveButton?.addEventListener('click', saveEntry);
                deleteButton?.addEventListener('click', handleDeleteEntry);
                cancelEditingButton?.addEventListener('click', resetEditingState);
                
                document.addEventListener('keydown', (e) => {
                    if ((e.metaKey || e.ctrlKey) && e.key === 's') {
                        e.preventDefault();
                        if (!saveButton.disabled) {
                            saveEntry();
                        }
                    }
                    
                    if (e.key === 'Escape' && !successModal.classList.contains('hidden')) {
                        closeModal.click();
                    }
                });
                
                window.addEventListener('load', () => {
                    writingArea.focus();
                    autoResize();
                });
                
                closeModal?.addEventListener('click', () => {
                    successModal.classList.add('hidden');
                    successModal.classList.remove('modal-visible');
                    window.location.href = 'index.html';
                });
                
                window.addEventListener('storage', (event) => {
                    if (event.key === DRAFT_KEY) {
                        applyDraftIfRelevant();
                    }
                });
                
                window.addEventListener('nuuko:storage', (event) => {
                    if (event?.detail?.type === 'settings' && !editingEntry) {
                        syncPromptFromSettings();
                    }
                });
                
                setInterval(persistDraft, 30000);
            }
            
            function syncPromptFromSettings() {
                let prompt = 'what surprised you today?';
                if (window.NuukoStorage) {
                    prompt = NuukoStorage.getSettingsSnapshot().currentPrompt || prompt;
                } else {
                    prompt = localStorage.getItem('nuuko_current_prompt') || prompt;
                }
                
                if (writePagePrompt && !editingEntry && !currentPromptData) {
                    writePagePrompt.textContent = prompt;
                }
            }

            function applyPromptToUI(prompt) {
                if (editingEntry) return;
                updatePromptDisplays(prompt, { animateHome: true, animateWrite: true });
                saveCurrentPrompt(prompt);
                closePromptEditor(false);
            }

            async function loadEnginePrompt() {
                if (!promptEngine || editingEntry) return;
                try {
                    currentPromptData = await promptEngine.getPrompt();
                    applyPromptToUI(currentPromptData.primaryPrompt);
                } catch (error) {
                    console.warn('[Nuuko] prompt engine unavailable, using stored prompt', error);
                }
            }

            function saveCurrentPrompt(prompt) {
                if (!prompt) return;
                if (window.NuukoStorage) {
                    NuukoStorage.updateSettings({ currentPrompt: prompt });
                } else {
                    localStorage.setItem('nuuko_current_prompt', prompt);
                }
            }
            function evaluatePageTitle() {
                if (!pageTitle) return;
                const entries = window.NuukoStorage
                    ? NuukoStorage.getEntriesSnapshot()
                    : JSON.parse(localStorage.getItem('nuuko_entries') || '[]');
                
                if (entries.length === 0) {
                    pageTitle.value = 'first entry';
                    pageTitle.placeholder = 'first entry';
                } else if (!editingEntry) {
                    pageTitle.value = 'new entry';
                    pageTitle.placeholder = 'new entry';
                }
            }
            
            function getMoodFromPosition(position) {
                const index = Math.floor((position / 100) * moods.length);
                return moods[Math.min(index, moods.length - 1)];
            }
            
            function setMoodFromValue(value) {
                if (!value) return;
                const index = moods.indexOf(value);
                if (index === -1) return;
                const percentage = (index / (moods.length - 1)) * 100;
                setMoodPosition(percentage);
            }
            
            function setMoodPosition(position) {
                currentMoodPosition = Math.max(0, Math.min(100, position));
                if (moodThumb) {
                    moodThumb.style.left = currentMoodPosition + '%';
                }
                updateMoodDisplay();
            }
            
            function updateMoodDisplay() {
                if (!currentMoodDisplay) return;
                currentMoodDisplay.textContent = getMoodFromPosition(currentMoodPosition);
            }
            
            function updateStats() {
                const text = writingArea.value.trim();
                const words = text === '' ? 0 : text.split(/\s+/).filter(Boolean).length;
                
                wordCount = words;
                wordCountDisplay.textContent = wordCount;
                
                const readingMinutes = Math.max(1, Math.ceil(wordCount / 200));
                readingTimeDisplay.textContent = readingMinutes + ' min';
                
                saveButton.disabled = wordCount === 0;
                saveButton.style.opacity = wordCount === 0 ? '0.5' : '1';
                saveButton.style.cursor = wordCount === 0 ? 'not-allowed' : 'pointer';
            }
            
            function autoResize() {
                writingArea.style.height = 'auto';
                writingArea.style.height = Math.max(600, writingArea.scrollHeight) + 'px';
            }
            
            function showError(message) {
                if (!errorMessage) return;
                errorMessage.querySelector('p').textContent = message;
                errorMessage.classList.remove('hidden');
                clearStatus();
            }
            
            function hideError() {
                errorMessage?.classList.add('hidden');
            }
            
            function showStatus(message, tone = 'success') {
                if (!statusBanner || !message) return;
                const styles = {
                    success: {
                        background: 'rgba(107, 143, 113, 0.12)',
                        border: 'rgba(107, 143, 113, 0.3)',
                        color: 'var(--nuuko-green)'
                    },
                    error: {
                        background: 'rgba(214, 126, 126, 0.12)',
                        border: 'rgba(214, 126, 126, 0.4)',
                        color: 'var(--mood-anxious)'
                    },
                    info: {
                        background: 'rgba(154, 107, 81, 0.12)',
                        border: 'rgba(154, 107, 81, 0.3)',
                        color: 'var(--nuuko-clay)'
                    }
                };
                const palette = styles[tone] || styles.success;
                statusBanner.textContent = message;
                statusBanner.style.background = palette.background;
                statusBanner.style.borderColor = palette.border;
                statusBanner.style.color = palette.color;
                statusBanner.classList.remove('hidden');
            }
            
            function clearStatus() {
                statusBanner?.classList.add('hidden');
            }
            
            async function loadEntryForEditing(entryId) {
                await storageReady;
                const entry = await fetchEntry(entryId);
                
                if (!entry) {
                    showError('we could not find that page. starting a fresh one instead.');
                    resetEditingState();
                    return;
                }
                
                editingEntry = entry;
                originalUpdatedAt = entry.updatedAt || entry.createdAt;
                
                if (writePagePrompt && entry.prompt) {
                    writePagePrompt.textContent = entry.prompt;
                }
                
                applyEntryContent(entry);
                if (tagsInput) {
                if (tagsInput) {
                    tagsInput.value = formatTags(entry.tags);
                }
                }
                summaryToggle.checked = entry.includeInSummaries !== false;
                
                deleteButton.classList.remove('hidden');
                editingBanner?.classList.remove('hidden');
                if (pageTitle) {
                    pageTitle.value = entry.title || 'entry';
                }
                if (dateInput && entry.createdAt) {
                    const entryDate = startOfDay(new Date(entry.createdAt));
                    dateInput.value = formatDateInput(entryDate);
                    updateDateDisplay(entryDate);
                    calendarCursor = startOfMonth(entryDate);
                    renderCalendar();
                }

                const formattedDate = entry.createdAt
                    ? new Date(entry.createdAt).toLocaleDateString('en-US', { month: 'long', day: 'numeric' }).toLowerCase()
                    : 'this page';
                editingBannerText.textContent = `editing entry from ${formattedDate}`;
                saveButtonText.textContent = 'save changes';
                
                applyDraftIfRelevant(true);
                showStatus('loaded your earlier page', 'info');
            }
            
            function applyEntryContent(entry) {
                writingArea.value = entry.content || '';
                setMoodFromValue(entry.mood);
                updateStats();
                autoResize();
            }
            
            async function saveEntry() {
                hideError();
                clearStatus();
                
                const content = writingArea.value.trim();
                if (content.length < 10) {
                    showError('please write a bit more to save your reflection');
                    return;
                }
                
                saveButtonText.textContent = editingEntry ? 'saving changes...' : 'saving...';
                saveButton.disabled = true;
                
                const promptSnapshot = writePagePrompt?.textContent?.trim() || '';
                const titleValue = (pageTitle?.value || '').trim() || 'entry';
                const createdAtISO = getSelectedDateISO();
                const createdAtDate = new Date(createdAtISO);
                const tagsArray = parseTagsFromInput();
                const timeBucket = bucketTimeOfDay(createdAtDate);
                const openingPhrase = extractOpeningPhrase(content);
                const startingPhraseCategory = categorizeOpeningPhrase(content);
                const topics = deriveTopicsFromTags(tagsArray, content);

                const entryPayload = {
                    ...(editingEntry || {}),
                    id: editingEntry ? editingEntry.id : Date.now(),
                    content,
                    mood: getMoodFromPosition(currentMoodPosition),
                    tags: tagsArray,
                    topics,
                    timeBucket,
                    openingPhrase,
                    startingPhraseCategory,
                    wordCount,
                    createdAt: createdAtISO,
                    updatedAt: new Date().toISOString(),
                    title: titleValue,
                    date: currentDateLabel,
                    prompt: promptSnapshot,
                    promptId: promptSnapshot ? generatePromptId(promptSnapshot) : undefined,
                    includeInSummaries: summaryToggle?.checked !== false
                };
                
                try {
                    if (editingEntry && window.NuukoStorage?.getEntryById) {
                        const latest = await NuukoStorage.getEntryById(editingEntry.id);
                        if (latest && latest.updatedAt && originalUpdatedAt && latest.updatedAt !== originalUpdatedAt) {
                            const overwrite = confirm('This page was updated in another tab. Replace it with your copy?');
                            if (!overwrite) {
                                saveButton.disabled = false;
                                saveButtonText.textContent = 'save changes';
                                showStatus('kept the latest version from the other tab.', 'info');
                                return;
                            }
                        }
                    }
                    
                    if (window.NuukoStorage) {
                        await storageReady;
                        await NuukoStorage.saveEntry(entryPayload);
                        persistDraft();
                    } else {
                        const entries = JSON.parse(localStorage.getItem('nuuko_entries') || '[]');
                        let updated = [];
                        if (editingEntry) {
                            updated = entries.map((item) => item.id === editingEntry.id ? entryPayload : item);
                        } else {
                            updated = [entryPayload, ...entries].slice(0, 50);
                        }
                        localStorage.setItem('nuuko_entries', JSON.stringify(updated));
                        
                        const stats = JSON.parse(localStorage.getItem('nuuko_stats') || '{}');
                        stats.totalEntries = editingEntry ? updated.length : (stats.totalEntries || 0) + 1;
                        stats.totalWords = (stats.totalWords || 0) - (editingEntry?.wordCount || 0) + wordCount;
                        stats.lastEntryDate = entryPayload.createdAt;
                        localStorage.setItem('nuuko_stats', JSON.stringify(stats));
                    }
                    
                    if (editingEntry) {
                        const latest = window.NuukoStorage?.getEntryById
                            ? await NuukoStorage.getEntryById(entryPayload.id)
                            : entryPayload;
                        editingEntry = latest;
                        originalUpdatedAt = latest?.updatedAt || entryPayload.updatedAt;
                        saveButton.disabled = false;
                        saveButtonText.textContent = 'save changes';
                        showStatus('changes saved', 'success');
                        persistDraft();
                    } else {
                        clearDraft();
                        writingArea.value = '';
                        if (tagsInput) {
                        if (tagsInput) {
                            tagsInput.value = '';
                        }
                        }
                        summaryToggle.checked = true;
                        updateStats();
                        autoResize();
                        successModal.classList.remove('hidden');
                        successModal.classList.add('modal-visible');
                        saveButtonText.textContent = 'save page';
                        evaluatePageTitle();
                    }
                } catch (error) {
                    console.error('[Nuuko] failed to save entry', error);
                    showError('we could not save your reflection. please try again.');
                    saveButton.disabled = false;
                    saveButtonText.textContent = editingEntry ? 'save changes' : 'save page';
                }
            }
            
            async function handleDeleteEntry() {
                if (!editingEntry) return;
                const confirmed = confirm('Delete this entry? This cannot be undone.');
                if (!confirmed) return;
                
                try {
                    if (window.NuukoStorage) {
                        await storageReady;
                        await NuukoStorage.deleteEntry(editingEntry.id);
                    } else {
                        const entries = JSON.parse(localStorage.getItem('nuuko_entries') || '[]').filter(entry => entry.id !== editingEntry.id);
                        localStorage.setItem('nuuko_entries', JSON.stringify(entries));
                    }
                    clearDraft();
                    showStatus('entry deleted', 'error');
                    window.location.href = 'index.html';
                } catch (error) {
                    console.error('[Nuuko] failed to delete entry', error);
                    showError('could not delete this entry. please try again.');
                }
            }
            
            function resetEditingState() {
                editingEntry = null;
                originalUpdatedAt = null;
                writingArea.value = '';
                if (tagsInput) {
                if (tagsInput) {
                    tagsInput.value = '';
                }
                }
                summaryToggle.checked = true;
                deleteButton.classList.add('hidden');
                editingBanner?.classList.add('hidden');
                saveButtonText.textContent = 'save page';
                if (pageTitle) {
                    pageTitle.value = 'new entry';
                    pageTitle.placeholder = 'new entry';
                }
                evaluatePageTitle();
                updateStats();
                autoResize();
                syncPromptFromSettings();
                const today = startOfDay(new Date());
                initializeDateControls(today);
                updateDateDisplay(today);
                window.history.replaceState({}, '', 'write.html');
                clearDraft();
                clearStatus();
                showStatus('starting a fresh page', 'info');
        }

        function parseTagsFromInput() {
            if (!tagsInput) return [];
            return tagsInput.value
                .split(',')
                .map(tag => tag.trim().toLowerCase())
                .filter(Boolean);
        }

        const TOPIC_KEYWORDS = {
            work: ['work', 'career', 'boss', 'office', 'client', 'job', 'deadline'],
            social: ['friend', 'friends', 'party', 'gathering', 'social', 'date', 'family'],
            health: ['health', 'body', 'exercise', 'sleep', 'run', 'workout', 'meditation', 'yoga'],
            self: ['self', 'mind', 'goal', 'dream', 'journal', 'reflection', 'feel', 'feelings']
        };

        function bucketTimeOfDay(date) {
            const hour = date.getHours();
            if (hour >= 5 && hour < 12) return 'morning';
            if (hour >= 12 && hour < 17) return 'afternoon';
            if (hour >= 17 && hour < 21) return 'evening';
            return 'night';
        }

        function extractOpeningPhrase(text = '') {
            if (!text) return '';
            const cleaned = text.trim().split(/\s+/).slice(0, 6).join(' ');
            return cleaned.toLowerCase();
        }

        function categorizeOpeningPhrase(text = '') {
            const cleaned = text.trim().toLowerCase();
            if (cleaned.startsWith('i feel')) return 'i_feel';
            if (cleaned.startsWith('today')) return 'today';
            if (cleaned.startsWith('dear')) return 'dear';
            if (cleaned.includes('?')) return 'question';
            return 'other';
        }

        function deriveTopicsFromTags(tags = [], content = '') {
            const topics = new Set();
            const loweredContent = content.toLowerCase();
            Object.entries(TOPIC_KEYWORDS).forEach(([topic, keywords]) => {
                const hasTag = tags.some(tag => keywords.includes(tag) || tag === topic);
                const hasKeyword = keywords.some(keyword => loweredContent.includes(keyword));
                if (hasTag || hasKeyword) {
                    topics.add(topic);
                }
            });
            if (topics.size === 0 && tags.length > 0) {
                topics.add('self');
            }
            return Array.from(topics);
        }
            
            function formatTags(tags = []) {
                if (!Array.isArray(tags)) return '';
                return tags.join(', ');
            }
            
            function generatePromptId(text = '') {
                return text
                    .toLowerCase()
                    .replace(/[^a-z0-9]+/g, '-')
                    .replace(/^-+|-+$/g, '')
                    .slice(0, 60);
            }
            
            function persistDraft() {
                const draft = {
                    content: writingArea.value,
                    moodPosition: currentMoodPosition,
                    tagsValue: tagsInput?.value || '',
                    summaryIncluded: summaryToggle?.checked !== false,
                    entryDate: dateInput?.value || '',
                    entryTitle: pageTitle?.value || '',
                    entryId: editingEntry ? editingEntry.id : null,
                    timestamp: Date.now()
                };
                
                if (!draft.content && !draft.tagsValue) {
                    clearDraft();
                    return;
                }
                
                localStorage.setItem(DRAFT_KEY, JSON.stringify(draft));
            }
            
            function clearDraft() {
                localStorage.removeItem(DRAFT_KEY);
            }
            
            function applyDraftIfRelevant(force = false) {
                const raw = localStorage.getItem(DRAFT_KEY);
                if (!raw) return;
                
                let draft;
                try {
                    draft = JSON.parse(raw);
                } catch {
                    return;
                }
                
                const editingId = editingEntry ? String(editingEntry.id) : null;
                const draftId = draft.entryId ? String(draft.entryId) : null;
                
                if (!force) {
                    if (draftId && (!editingId || draftId !== editingId)) return;
                    if (!draftId && editingId) return;
                } else if (draftId && editingId && draftId !== editingId) {
                    return;
                }
                
                if (draft.content) {
                    writingArea.value = draft.content;
                    updateStats();
                    autoResize();
                }
                
                if (typeof draft.moodPosition === 'number') {
                    setMoodPosition(draft.moodPosition);
                }
                
                if (draft.tagsValue !== undefined && tagsInput) {
                    tagsInput.value = draft.tagsValue;
                }

                if (typeof draft.summaryIncluded === 'boolean' && summaryToggle) {
                    summaryToggle.checked = draft.summaryIncluded;
                }

                if (draft.entryDate && dateInput) {
                    dateInput.value = draft.entryDate;
                    handleDateChange();
                }

                if (draft.entryTitle && pageTitle) {
                    pageTitle.value = draft.entryTitle;
                }
            }
            
            async function fetchEntry(entryId) {
                if (window.NuukoStorage?.getEntryById) {
                    return NuukoStorage.getEntryById(entryId);
                }
                const entries = JSON.parse(localStorage.getItem('nuuko_entries') || '[]');
                return entries.find(entry => String(entry.id) === String(entryId));
            }
            
            function openPromptEditor() {
                if (!promptEditor || !promptEditInput) return;
                promptEditInput.value = writePagePrompt?.textContent?.trim() || '';
                promptEditor.classList.remove('hidden');
                setTimeout(() => promptEditInput.focus(), 30);
            }

            function closePromptEditor(reset = true) {
                if (!promptEditor || !promptEditInput) return;
                if (reset) {
                    promptEditInput.value = writePagePrompt?.textContent || '';
                }
                promptEditor.classList.add('hidden');
            }

            function saveEditedPrompt() {
                if (!promptEditInput) return;
                const nextPrompt = promptEditInput.value.trim();
                if (!nextPrompt) {
                    alert('Write a prompt or cancel editing.');
                    promptEditInput.focus();
                    return;
                }
                applyPromptToUI(nextPrompt);
            }

            function hidePromptCard() {
                if (!promptSectionCard || !promptHiddenNotice) return;
                promptSectionCard.classList.add('hidden');
                promptHiddenNotice.classList.remove('hidden');
            }

            function showPromptCard() {
                if (!promptSectionCard || !promptHiddenNotice) return;
                promptSectionCard.classList.remove('hidden');
                promptHiddenNotice.classList.add('hidden');
            }

            window.startPromptEdit = openPromptEditor;
            window.cancelPromptEdit = () => closePromptEditor(true);
            window.savePromptEdit = saveEditedPrompt;
            window.dismissPromptSection = hidePromptCard;
            window.restorePromptSection = showPromptCard;

            window.changePrompt = async function changePrompt() {
                if (promptEngine && !editingEntry) {
                    try {
                        const next = currentPromptData
                            ? await promptEngine.refreshPrompt()
                            : await promptEngine.getPrompt();
                        currentPromptData = next;
                        applyPromptToUI(next.primaryPrompt);
                        return;
                    } catch (error) {
                        console.warn('[Nuuko] prompt refresh fallback', error);
                    }
                }

                const currentPrompt = writePagePrompt?.textContent || 'what surprised you today?';
                const newPrompt = FALLBACK_PROMPTS.find((p) => p !== currentPrompt) || currentPrompt;
                applyPromptToUI(newPrompt);
            };

            function initializeDateControls(today) {
                if (!dateInput) return;
                const todayInput = formatDateInput(today);
                dateInput.max = todayInput;
                if (!dateInput.value) {
                    dateInput.value = todayInput;
                }
                calendarCursor = startOfMonth(parseDateInput(dateInput.value) || today);
                renderCalendar();
            }

            function handleDateChange() {
                if (!dateInput) return;
                const parsed = parseDateInput(dateInput.value);
                const today = startOfDay(new Date());
                let finalDate = parsed || today;
                if (finalDate.getTime() > today.getTime()) {
                    finalDate = today;
                    dateInput.value = formatDateInput(finalDate);
                    showStatus('future dates are not allowed, using today instead.', 'info');
                }
                updateDateDisplay(finalDate);
                calendarCursor = startOfMonth(finalDate);
                renderCalendar();
                persistDraft();
            }

            function getSelectedDateISO() {
                if (!dateInput) return new Date().toISOString();
                const parsed = parseDateInput(dateInput.value);
                const today = startOfDay(new Date());
                const safeDate = parsed && parsed.getTime() <= today.getTime() ? parsed : today;
                // Anchor at noon local time to avoid timezone rollover
                safeDate.setHours(12, 0, 0, 0);
                return safeDate.toISOString();
            }

            function parseDateInput(value) {
                if (!value) return null;
                const [year, month, day] = value.split('-').map((v) => parseInt(v, 10));
                if (!year || !month || !day) return null;
                const date = new Date(year, month - 1, day);
                if (Number.isNaN(date.getTime())) return null;
                return startOfDay(date);
            }

            function formatDateInput(date) {
                const d = new Date(date);
                const year = d.getFullYear();
                const month = String(d.getMonth() + 1).padStart(2, '0');
                const day = String(d.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            }

            function startOfDay(date) {
                const d = new Date(date);
                d.setHours(0, 0, 0, 0);
                return d;
            }

            function startOfMonth(date) {
                const d = new Date(date);
                d.setDate(1);
                d.setHours(0, 0, 0, 0);
                return d;
            }

            function updateDateDisplay(date) {
                if (!currentDateDisplay) return;
                const label = date.toLocaleDateString('en-US', {
                    weekday: 'long',
                    month: 'long',
                    day: 'numeric'
                }).toLowerCase();
                currentDateLabel = label;
                currentDateDisplay.textContent = label;
                if (dateDisplayValue) {
                    dateDisplayValue.textContent = date.toLocaleDateString('en-US');
                }
            }

            function toggleCalendar() {
                if (!datePopover) return;
                const isHidden = datePopover.classList.contains('hidden');
                if (isHidden) {
                    renderCalendar();
                    datePopover.classList.remove('hidden');
                    datePickerTrigger?.setAttribute('aria-expanded', 'true');
                } else {
                    closeCalendar();
                }
            }

            function closeCalendar() {
                datePopover?.classList.add('hidden');
                datePickerTrigger?.setAttribute('aria-expanded', 'false');
            }

            function handleClickOutsideCalendar(event) {
                if (!datePopover || datePopover.classList.contains('hidden')) return;
                if (datePopover.contains(event.target) || datePickerTrigger.contains(event.target)) return;
                closeCalendar();
            }

            function shiftCalendar(deltaMonths) {
                if (typeof deltaMonths !== 'number') return;
                const next = new Date(calendarCursor);
                next.setMonth(next.getMonth() + deltaMonths);
                const today = startOfMonth(startOfDay(new Date()));
                if (next > today) {
                    calendarCursor = today;
                } else {
                    calendarCursor = next;
                }
                renderCalendar();
            }

            function jumpToDate(date) {
                if (!dateInput) return;
                dateInput.value = formatDateInput(date);
                handleDateChange();
                closeCalendar();
            }

            function renderCalendar() {
                if (!dateGrid || !dateMonthLabel || !dateWeekdays) return;
                const today = startOfDay(new Date());
                const selected = parseDateInput(dateInput?.value) || today;
                const monthStart = startOfMonth(calendarCursor || selected);
                const monthLabel = monthStart.toLocaleDateString('en-US', { month: 'long', year: 'numeric' }).toLowerCase();
                dateMonthLabel.textContent = monthLabel;

                if (!dateWeekdays.dataset.filled) {
                    const days = ['s', 'm', 't', 'w', 't', 'f', 's'];
                    dateWeekdays.innerHTML = days.map((d) => `<span>${d}</span>`).join('');
                    dateWeekdays.dataset.filled = 'true';
                }

                const daysInMonth = new Date(monthStart.getFullYear(), monthStart.getMonth() + 1, 0).getDate();
                const todayMonth = startOfMonth(today);
                const isCurrentMonth = monthStart.getTime() === todayMonth.getTime();
                if (dateNextMonth) {
                    dateNextMonth.disabled = isCurrentMonth;
                    dateNextMonth.classList.toggle('disabled', isCurrentMonth);
                }
                const firstDayIndex = monthStart.getDay();
                const cells = [];
                for (let i = 0; i < firstDayIndex; i += 1) {
                    cells.push('<div></div>');
                }
                for (let day = 1; day <= daysInMonth; day += 1) {
                    const current = new Date(monthStart);
                    current.setDate(day);
                    const currentKey = current.toISOString();
                    const isToday = current.getTime() === today.getTime();
                    const isSelected = selected && current.getTime() === selected.getTime();
                    const isFuture = current.getTime() > today.getTime();
                    const classes = ['date-day'];
                    if (isToday) classes.push('today');
                    if (isSelected) classes.push('selected');
                    if (isFuture) classes.push('disabled');
                    const disabledAttr = isFuture ? 'aria-disabled="true"' : '';
                    cells.push(`
                        <button type="button" class="${classes.join(' ')}" data-date="${currentKey}" ${disabledAttr}>
                            ${day}
                        </button>
                    `);
                }

                dateGrid.innerHTML = cells.join('');
                dateGrid.querySelectorAll('.date-day').forEach((button) => {
                    button.addEventListener('click', () => {
                        if (button.classList.contains('disabled')) return;
                        const value = button.dataset.date;
                        if (!value || !dateInput) return;
                        dateInput.value = value.slice(0, 10);
                        handleDateChange();
                        closeCalendar();
                    });
                });
            }
        })();
    </script>
</body>
</html>
